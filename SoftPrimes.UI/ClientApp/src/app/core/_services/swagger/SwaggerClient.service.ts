/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.18.3.0 (NJsonSchema v9.10.67.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class SwaggerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param culture (optional) 
     * @param body (optional) 
     * @return Success
     */
    apiAccountLoginPost(culture: string, body: UserLoginModel): Observable<AccessToken> {
        let url_ = this.baseUrl + "/api/Account/Login?";
        if (culture !== undefined)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountLoginPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountLoginPost(<any>response_);
                } catch (e) {
                    return <Observable<AccessToken>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessToken>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountLoginPost(response: HttpResponseBase): Observable<AccessToken> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessToken.fromJS(resultData200) : new AccessToken();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessToken>(<any>null);
    }

    /**
     * @return Success
     */
    apiAccountGetUserAuthTicketGet(): Observable<AuthTicketDTO> {
        let url_ = this.baseUrl + "/api/Account/GetUserAuthTicket";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetUserAuthTicketGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetUserAuthTicketGet(<any>response_);
                } catch (e) {
                    return <Observable<AuthTicketDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthTicketDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountGetUserAuthTicketGet(response: HttpResponseBase): Observable<AuthTicketDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthTicketDTO.fromJS(resultData200) : new AuthTicketDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthTicketDTO>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    apiAccountLogoutGet(refreshToken: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/Logout?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountLogoutGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountLogoutGet(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountLogoutGet(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAccountContactUsPost(body: MessageDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/ContactUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountContactUsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountContactUsPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountContactUsPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    apiAccountGetUserProfileGet(userId: string): Observable<AgentDTO> {
        let url_ = this.baseUrl + "/api/Account/GetUserProfile?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetUserProfileGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetUserProfileGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountGetUserProfileGet(response: HttpResponseBase): Observable<AgentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentDTO.fromJS(resultData200) : new AgentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO>(<any>null);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    apiAccountResetPasswordGet(email: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword?";
        if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountResetPasswordGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountResetPasswordGet(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountResetPasswordGet(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAccountInsertNewUsersPost(body: AgentDTO[]): Observable<AgentDTO[]> {
        let url_ = this.baseUrl + "/api/Account/InsertNewUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountInsertNewUsersPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountInsertNewUsersPost(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountInsertNewUsersPost(response: HttpResponseBase): Observable<AgentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAccountUpdateUsersPut(body: AgentDetailsDTO): Observable<AgentDTO> {
        let url_ = this.baseUrl + "/api/Account/UpdateUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountUpdateUsersPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountUpdateUsersPut(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountUpdateUsersPut(response: HttpResponseBase): Observable<AgentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentDTO.fromJS(resultData200) : new AgentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    apiAccountAddUserImagePost(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Account/AddUserImage?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountAddUserImagePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountAddUserImagePost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountAddUserImagePost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param newPassword (optional) 
     * @return Success
     */
    apiAccountChangeTempPasswordGet(userName: string, newPassword: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/ChangeTempPassword?";
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountChangeTempPasswordGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountChangeTempPasswordGet(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountChangeTempPasswordGet(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param searchText (optional) 
     * @param take (optional) 
     * @return Success
     */
    apiAccountGetAgentLookupsGet(searchText: string, take: number): Observable<AgentDTO[]> {
        let url_ = this.baseUrl + "/api/Account/GetAgentLookups?";
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAccountGetAgentLookupsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAccountGetAgentLookupsGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAccountGetAgentLookupsGet(response: HttpResponseBase): Observable<AgentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO[]>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentLocationLogsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentLocationLogDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/AgentLocationLogs/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLocationLogsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLocationLogsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentLocationLogDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLocationLogDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLocationLogsGetAllGet(response: HttpResponseBase): Observable<AgentLocationLogDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentLocationLogDTODataSourceResult.fromJS(resultData200) : new AgentLocationLogDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLocationLogDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentLocationLogsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentLocationLogDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/AgentLocationLogs/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLocationLogsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLocationLogsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentLocationLogDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLocationLogDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLocationLogsGetAllDetailsGet(response: HttpResponseBase): Observable<AgentLocationLogDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentLocationLogDTODataSourceResult.fromJS(resultData200) : new AgentLocationLogDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLocationLogDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiAgentLocationLogsGetByIdGet(id: number): Observable<AgentLocationLogDTO> {
        let url_ = this.baseUrl + "/api/AgentLocationLogs/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLocationLogsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLocationLogsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentLocationLogDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLocationLogDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLocationLogsGetByIdGet(response: HttpResponseBase): Observable<AgentLocationLogDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentLocationLogDTO.fromJS(resultData200) : new AgentLocationLogDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLocationLogDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentLocationLogsInsertPost(body: AgentLocationLogDTO[]): Observable<AgentLocationLogDTO[]> {
        let url_ = this.baseUrl + "/api/AgentLocationLogs/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLocationLogsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLocationLogsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<AgentLocationLogDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLocationLogDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLocationLogsInsertPost(response: HttpResponseBase): Observable<AgentLocationLogDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentLocationLogDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLocationLogDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentLocationLogsUpdatePut(body: AgentLocationLogDTO[]): Observable<AgentLocationLogDTO[]> {
        let url_ = this.baseUrl + "/api/AgentLocationLogs/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLocationLogsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLocationLogsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<AgentLocationLogDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLocationLogDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLocationLogsUpdatePut(response: HttpResponseBase): Observable<AgentLocationLogDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentLocationLogDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLocationLogDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiAgentLocationLogsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/AgentLocationLogs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLocationLogsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLocationLogsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLocationLogsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentLocationLogsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AgentLocationLogs/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLocationLogsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLocationLogsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLocationLogsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentLoginLogsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentLoginLogDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/AgentLoginLogs/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLoginLogsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLoginLogsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentLoginLogDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLoginLogDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLoginLogsGetAllGet(response: HttpResponseBase): Observable<AgentLoginLogDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentLoginLogDTODataSourceResult.fromJS(resultData200) : new AgentLoginLogDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLoginLogDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentLoginLogsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentLoginLogDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/AgentLoginLogs/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLoginLogsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLoginLogsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentLoginLogDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLoginLogDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLoginLogsGetAllDetailsGet(response: HttpResponseBase): Observable<AgentLoginLogDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentLoginLogDTODataSourceResult.fromJS(resultData200) : new AgentLoginLogDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLoginLogDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiAgentLoginLogsGetByIdGet(id: number): Observable<AgentLoginLogDTO> {
        let url_ = this.baseUrl + "/api/AgentLoginLogs/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLoginLogsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLoginLogsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentLoginLogDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLoginLogDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLoginLogsGetByIdGet(response: HttpResponseBase): Observable<AgentLoginLogDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentLoginLogDTO.fromJS(resultData200) : new AgentLoginLogDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLoginLogDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentLoginLogsInsertPost(body: AgentLoginLogDTO[]): Observable<AgentLoginLogDTO[]> {
        let url_ = this.baseUrl + "/api/AgentLoginLogs/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLoginLogsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLoginLogsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<AgentLoginLogDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLoginLogDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLoginLogsInsertPost(response: HttpResponseBase): Observable<AgentLoginLogDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentLoginLogDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLoginLogDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentLoginLogsUpdatePut(body: AgentLoginLogDTO[]): Observable<AgentLoginLogDTO[]> {
        let url_ = this.baseUrl + "/api/AgentLoginLogs/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLoginLogsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLoginLogsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<AgentLoginLogDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentLoginLogDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLoginLogsUpdatePut(response: HttpResponseBase): Observable<AgentLoginLogDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentLoginLogDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentLoginLogDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiAgentLoginLogsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/AgentLoginLogs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLoginLogsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLoginLogsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLoginLogsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentLoginLogsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AgentLoginLogs/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentLoginLogsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentLoginLogsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentLoginLogsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentRolesGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentRoleDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/AgentRoles/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentRolesGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentRolesGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentRoleDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentRoleDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentRolesGetAllGet(response: HttpResponseBase): Observable<AgentRoleDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentRoleDTODataSourceResult.fromJS(resultData200) : new AgentRoleDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentRoleDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentRolesGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentRoleDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/AgentRoles/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentRolesGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentRolesGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentRoleDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentRoleDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentRolesGetAllDetailsGet(response: HttpResponseBase): Observable<AgentRoleDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentRoleDTODataSourceResult.fromJS(resultData200) : new AgentRoleDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentRoleDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiAgentRolesGetByIdGet(id: number): Observable<AgentRoleDTO> {
        let url_ = this.baseUrl + "/api/AgentRoles/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentRolesGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentRolesGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentRolesGetByIdGet(response: HttpResponseBase): Observable<AgentRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentRoleDTO.fromJS(resultData200) : new AgentRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentRoleDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentRolesInsertPost(body: AgentRoleDTO[]): Observable<AgentRoleDTO[]> {
        let url_ = this.baseUrl + "/api/AgentRoles/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentRolesInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentRolesInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<AgentRoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentRoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentRolesInsertPost(response: HttpResponseBase): Observable<AgentRoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentRoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentRoleDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentRolesUpdatePut(body: AgentRoleDTO[]): Observable<AgentRoleDTO[]> {
        let url_ = this.baseUrl + "/api/AgentRoles/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentRolesUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentRolesUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<AgentRoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentRoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentRolesUpdatePut(response: HttpResponseBase): Observable<AgentRoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentRoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentRoleDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiAgentRolesDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/AgentRoles/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentRolesDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentRolesDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentRolesDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentRolesIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AgentRoles/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentRolesIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentRolesIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentRolesIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentsInsertNewAgentPost(body: AgentDTO[]): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Agents/InsertNewAgent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsInsertNewAgentPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsInsertNewAgentPost(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsInsertNewAgentPost(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentsUpdateUsersPut(body: AgentDTO[]): Observable<AgentDTO[]> {
        let url_ = this.baseUrl + "/api/Agents/UpdateUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsUpdateUsersPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsUpdateUsersPut(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsUpdateUsersPut(response: HttpResponseBase): Observable<AgentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiAgentsModifyProfileImagesGet(): Observable<string> {
        let url_ = this.baseUrl + "/api/Agents/ModifyProfileImages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsModifyProfileImagesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsModifyProfileImagesGet(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsModifyProfileImagesGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    apiAgentsAddUserImagePost(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Agents/AddUserImage?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsAddUserImagePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsAddUserImagePost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsAddUserImagePost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    apiAgentsGetUserByUserNameGet(username: string): Observable<AgentDTO> {
        let url_ = this.baseUrl + "/api/Agents/GetUserByUserName?";
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsGetUserByUserNameGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsGetUserByUserNameGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsGetUserByUserNameGet(response: HttpResponseBase): Observable<AgentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentDTO.fromJS(resultData200) : new AgentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    apiAgentsGetByUserNameGet(username: string): Observable<AgentDTO> {
        let url_ = this.baseUrl + "/api/Agents/GetByUserName?";
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsGetByUserNameGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsGetByUserNameGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsGetByUserNameGet(response: HttpResponseBase): Observable<AgentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentDTO.fromJS(resultData200) : new AgentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Agents/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsGetAllGet(response: HttpResponseBase): Observable<AgentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentDTODataSourceResult.fromJS(resultData200) : new AgentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAgentsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AgentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Agents/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsGetAllDetailsGet(response: HttpResponseBase): Observable<AgentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentDTODataSourceResult.fromJS(resultData200) : new AgentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiAgentsGetByIdGet(id: number): Observable<AgentDTO> {
        let url_ = this.baseUrl + "/api/Agents/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsGetByIdGet(response: HttpResponseBase): Observable<AgentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AgentDTO.fromJS(resultData200) : new AgentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentsInsertPost(body: AgentDTO[]): Observable<AgentDTO[]> {
        let url_ = this.baseUrl + "/api/Agents/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsInsertPost(response: HttpResponseBase): Observable<AgentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentsUpdatePut(body: AgentDTO[]): Observable<AgentDTO[]> {
        let url_ = this.baseUrl + "/api/Agents/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<AgentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsUpdatePut(response: HttpResponseBase): Observable<AgentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AgentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiAgentsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Agents/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAgentsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Agents/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAgentsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAgentsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAgentsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAttachmentsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AttachmentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Attachments/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmentsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmentsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<AttachmentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttachmentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAttachmentsGetAllGet(response: HttpResponseBase): Observable<AttachmentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttachmentDTODataSourceResult.fromJS(resultData200) : new AttachmentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiAttachmentsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<AttachmentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Attachments/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmentsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmentsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<AttachmentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttachmentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiAttachmentsGetAllDetailsGet(response: HttpResponseBase): Observable<AttachmentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttachmentDTODataSourceResult.fromJS(resultData200) : new AttachmentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiAttachmentsGetByIdGet(id: number): Observable<AttachmentDTO> {
        let url_ = this.baseUrl + "/api/Attachments/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmentsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmentsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<AttachmentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttachmentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiAttachmentsGetByIdGet(response: HttpResponseBase): Observable<AttachmentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttachmentDTO.fromJS(resultData200) : new AttachmentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAttachmentsInsertPost(body: AttachmentDTO[]): Observable<AttachmentDTO[]> {
        let url_ = this.baseUrl + "/api/Attachments/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmentsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmentsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<AttachmentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttachmentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAttachmentsInsertPost(response: HttpResponseBase): Observable<AttachmentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AttachmentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAttachmentsUpdatePut(body: AttachmentDTO[]): Observable<AttachmentDTO[]> {
        let url_ = this.baseUrl + "/api/Attachments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmentsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmentsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<AttachmentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttachmentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAttachmentsUpdatePut(response: HttpResponseBase): Observable<AttachmentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AttachmentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiAttachmentsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Attachments/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmentsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmentsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiAttachmentsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiAttachmentsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Attachments/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmentsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmentsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiAttachmentsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param searchText (optional) 
     * @param take (optional) 
     * @return Success
     */
    apiCheckPointsGetCheckPointLookupsGet(searchText: string, take: number): Observable<CheckPointDTO[]> {
        let url_ = this.baseUrl + "/api/CheckPoints/GetCheckPointLookups?";
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsGetCheckPointLookupsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsGetCheckPointLookupsGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsGetCheckPointLookupsGet(response: HttpResponseBase): Observable<CheckPointDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CheckPointDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointDTO[]>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCheckPointsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CheckPointDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/CheckPoints/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsGetAllGet(response: HttpResponseBase): Observable<CheckPointDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckPointDTODataSourceResult.fromJS(resultData200) : new CheckPointDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCheckPointsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CheckPointDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/CheckPoints/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsGetAllDetailsGet(response: HttpResponseBase): Observable<CheckPointDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckPointDTODataSourceResult.fromJS(resultData200) : new CheckPointDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiCheckPointsGetByIdGet(id: number): Observable<CheckPointDTO> {
        let url_ = this.baseUrl + "/api/CheckPoints/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsGetByIdGet(response: HttpResponseBase): Observable<CheckPointDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckPointDTO.fromJS(resultData200) : new CheckPointDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCheckPointsInsertPost(body: CheckPointDTO[]): Observable<CheckPointDTO[]> {
        let url_ = this.baseUrl + "/api/CheckPoints/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsInsertPost(response: HttpResponseBase): Observable<CheckPointDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CheckPointDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCheckPointsUpdatePut(body: CheckPointDTO[]): Observable<CheckPointDTO[]> {
        let url_ = this.baseUrl + "/api/CheckPoints/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsUpdatePut(response: HttpResponseBase): Observable<CheckPointDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CheckPointDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiCheckPointsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/CheckPoints/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCheckPointsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CheckPoints/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCheckPointTourCommentsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CheckPointTourCommentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/CheckPointTourComments/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointTourCommentsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointTourCommentsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointTourCommentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointTourCommentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointTourCommentsGetAllGet(response: HttpResponseBase): Observable<CheckPointTourCommentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckPointTourCommentDTODataSourceResult.fromJS(resultData200) : new CheckPointTourCommentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointTourCommentDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCheckPointTourCommentsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CheckPointTourCommentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/CheckPointTourComments/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointTourCommentsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointTourCommentsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointTourCommentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointTourCommentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointTourCommentsGetAllDetailsGet(response: HttpResponseBase): Observable<CheckPointTourCommentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckPointTourCommentDTODataSourceResult.fromJS(resultData200) : new CheckPointTourCommentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointTourCommentDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiCheckPointTourCommentsGetByIdGet(id: number): Observable<CheckPointTourCommentDTO> {
        let url_ = this.baseUrl + "/api/CheckPointTourComments/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointTourCommentsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointTourCommentsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointTourCommentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointTourCommentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointTourCommentsGetByIdGet(response: HttpResponseBase): Observable<CheckPointTourCommentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckPointTourCommentDTO.fromJS(resultData200) : new CheckPointTourCommentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointTourCommentDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCheckPointTourCommentsInsertPost(body: CheckPointTourCommentDTO[]): Observable<CheckPointTourCommentDTO[]> {
        let url_ = this.baseUrl + "/api/CheckPointTourComments/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointTourCommentsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointTourCommentsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointTourCommentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointTourCommentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointTourCommentsInsertPost(response: HttpResponseBase): Observable<CheckPointTourCommentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CheckPointTourCommentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointTourCommentDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCheckPointTourCommentsUpdatePut(body: CheckPointTourCommentDTO[]): Observable<CheckPointTourCommentDTO[]> {
        let url_ = this.baseUrl + "/api/CheckPointTourComments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointTourCommentsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointTourCommentsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<CheckPointTourCommentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckPointTourCommentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointTourCommentsUpdatePut(response: HttpResponseBase): Observable<CheckPointTourCommentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CheckPointTourCommentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPointTourCommentDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiCheckPointTourCommentsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/CheckPointTourComments/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointTourCommentsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointTourCommentsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointTourCommentsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCheckPointTourCommentsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CheckPointTourComments/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCheckPointTourCommentsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCheckPointTourCommentsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiCheckPointTourCommentsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCommentsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CommentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Comments/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommentsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommentsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<CommentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCommentsGetAllGet(response: HttpResponseBase): Observable<CommentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDTODataSourceResult.fromJS(resultData200) : new CommentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCommentsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CommentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Comments/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommentsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommentsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<CommentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCommentsGetAllDetailsGet(response: HttpResponseBase): Observable<CommentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDTODataSourceResult.fromJS(resultData200) : new CommentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiCommentsGetByIdGet(id: number): Observable<CommentDTO> {
        let url_ = this.baseUrl + "/api/Comments/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommentsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommentsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<CommentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiCommentsGetByIdGet(response: HttpResponseBase): Observable<CommentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDTO.fromJS(resultData200) : new CommentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCommentsInsertPost(body: CommentDTO[]): Observable<CommentDTO[]> {
        let url_ = this.baseUrl + "/api/Comments/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommentsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommentsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<CommentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCommentsInsertPost(response: HttpResponseBase): Observable<CommentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCommentsUpdatePut(body: CommentDTO[]): Observable<CommentDTO[]> {
        let url_ = this.baseUrl + "/api/Comments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommentsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommentsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<CommentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCommentsUpdatePut(response: HttpResponseBase): Observable<CommentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiCommentsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Comments/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommentsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommentsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCommentsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCommentsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Comments/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommentsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommentsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiCommentsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCompaniesGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CompanyDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Companies/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCompaniesGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCompaniesGetAllGet(response: HttpResponseBase): Observable<CompanyDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyDTODataSourceResult.fromJS(resultData200) : new CompanyDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiCompaniesGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<CompanyDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Companies/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCompaniesGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiCompaniesGetAllDetailsGet(response: HttpResponseBase): Observable<CompanyDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyDTODataSourceResult.fromJS(resultData200) : new CompanyDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiCompaniesGetByIdGet(id: number): Observable<CompanyDTO> {
        let url_ = this.baseUrl + "/api/Companies/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCompaniesGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiCompaniesGetByIdGet(response: HttpResponseBase): Observable<CompanyDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyDTO.fromJS(resultData200) : new CompanyDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCompaniesInsertPost(body: CompanyDTO[]): Observable<CompanyDTO[]> {
        let url_ = this.baseUrl + "/api/Companies/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCompaniesInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCompaniesInsertPost(response: HttpResponseBase): Observable<CompanyDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CompanyDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCompaniesUpdatePut(body: CompanyDTO[]): Observable<CompanyDTO[]> {
        let url_ = this.baseUrl + "/api/Companies/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCompaniesUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCompaniesUpdatePut(response: HttpResponseBase): Observable<CompanyDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CompanyDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiCompaniesDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Companies/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCompaniesDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiCompaniesDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiCompaniesIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Companies/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCompaniesIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiCompaniesIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    apiLocalizationsJsonGet(culture: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Localizations/json/{culture}";
        if (culture === undefined || culture === null)
            throw new Error("The parameter 'culture' must be defined.");
        url_ = url_.replace("{culture}", encodeURIComponent("" + culture)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsJsonGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsJsonGet(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsJsonGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    apiLocalizationsGetLastUpDateTimeGet(): Observable<Date> {
        let url_ = this.baseUrl + "/api/Localizations/GetLastUpDateTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsGetLastUpDateTimeGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsGetLastUpDateTimeGet(<any>response_);
                } catch (e) {
                    return <Observable<Date>><any>_observableThrow(e);
                }
            } else
                return <Observable<Date>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsGetLastUpDateTimeGet(response: HttpResponseBase): Observable<Date> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Date>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiLocalizationsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<LocalizationDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Localizations/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsGetAllGet(response: HttpResponseBase): Observable<LocalizationDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationDTODataSourceResult.fromJS(resultData200) : new LocalizationDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiLocalizationsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<LocalizationDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Localizations/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsGetAllDetailsGet(response: HttpResponseBase): Observable<LocalizationDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationDTODataSourceResult.fromJS(resultData200) : new LocalizationDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiLocalizationsGetByIdGet(id: number): Observable<LocalizationDTO> {
        let url_ = this.baseUrl + "/api/Localizations/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsGetByIdGet(response: HttpResponseBase): Observable<LocalizationDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationDTO.fromJS(resultData200) : new LocalizationDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiLocalizationsInsertPost(body: LocalizationDTO[]): Observable<LocalizationDTO[]> {
        let url_ = this.baseUrl + "/api/Localizations/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsInsertPost(response: HttpResponseBase): Observable<LocalizationDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LocalizationDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiLocalizationsUpdatePut(body: LocalizationDTO[]): Observable<LocalizationDTO[]> {
        let url_ = this.baseUrl + "/api/Localizations/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsUpdatePut(response: HttpResponseBase): Observable<LocalizationDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LocalizationDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiLocalizationsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Localizations/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiLocalizationsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localizations/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiLocalizationsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiNotificationsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<NotificationDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Notifications/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiNotificationsGetAllGet(response: HttpResponseBase): Observable<NotificationDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NotificationDTODataSourceResult.fromJS(resultData200) : new NotificationDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiNotificationsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<NotificationDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Notifications/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiNotificationsGetAllDetailsGet(response: HttpResponseBase): Observable<NotificationDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NotificationDTODataSourceResult.fromJS(resultData200) : new NotificationDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiNotificationsGetByIdGet(id: number): Observable<NotificationDTO> {
        let url_ = this.baseUrl + "/api/Notifications/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiNotificationsGetByIdGet(response: HttpResponseBase): Observable<NotificationDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NotificationDTO.fromJS(resultData200) : new NotificationDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiNotificationsInsertPost(body: NotificationDTO[]): Observable<NotificationDTO[]> {
        let url_ = this.baseUrl + "/api/Notifications/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiNotificationsInsertPost(response: HttpResponseBase): Observable<NotificationDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NotificationDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiNotificationsUpdatePut(body: NotificationDTO[]): Observable<NotificationDTO[]> {
        let url_ = this.baseUrl + "/api/Notifications/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiNotificationsUpdatePut(response: HttpResponseBase): Observable<NotificationDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NotificationDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiNotificationsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Notifications/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiNotificationsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiNotificationsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Notifications/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiNotificationsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param searchText (optional) 
     * @param take (optional) 
     * @return Success
     */
    apiPermissionsGetPermissionLookupsGet(searchText: string, take: number): Observable<PermissionDTO[]> {
        let url_ = this.baseUrl + "/api/Permissions/GetPermissionLookups?";
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsGetPermissionLookupsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsGetPermissionLookupsGet(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsGetPermissionLookupsGet(response: HttpResponseBase): Observable<PermissionDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PermissionDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDTO[]>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiPermissionsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<PermissionDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Permissions/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsGetAllGet(response: HttpResponseBase): Observable<PermissionDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionDTODataSourceResult.fromJS(resultData200) : new PermissionDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiPermissionsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<PermissionDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Permissions/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsGetAllDetailsGet(response: HttpResponseBase): Observable<PermissionDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionDTODataSourceResult.fromJS(resultData200) : new PermissionDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiPermissionsGetByIdGet(id: number): Observable<PermissionDTO> {
        let url_ = this.baseUrl + "/api/Permissions/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsGetByIdGet(response: HttpResponseBase): Observable<PermissionDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionDTO.fromJS(resultData200) : new PermissionDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiPermissionsInsertPost(body: PermissionDTO[]): Observable<PermissionDTO[]> {
        let url_ = this.baseUrl + "/api/Permissions/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsInsertPost(response: HttpResponseBase): Observable<PermissionDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PermissionDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiPermissionsUpdatePut(body: PermissionDTO[]): Observable<PermissionDTO[]> {
        let url_ = this.baseUrl + "/api/Permissions/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsUpdatePut(response: HttpResponseBase): Observable<PermissionDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PermissionDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiPermissionsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Permissions/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiPermissionsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Permissions/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPermissionsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPermissionsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiPermissionsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiRolesInsertRolePost(body: RoleDetailsDTO[]): Observable<RoleDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/Roles/InsertRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesInsertRolePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesInsertRolePost(<any>response_);
                } catch (e) {
                    return <Observable<RoleDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesInsertRolePost(response: HttpResponseBase): Observable<RoleDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RoleDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDetailsDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiRolesUpdateRolePut(body: RoleDetailsDTO[]): Observable<RoleDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/Roles/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesUpdateRolePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesUpdateRolePut(<any>response_);
                } catch (e) {
                    return <Observable<RoleDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesUpdateRolePut(response: HttpResponseBase): Observable<RoleDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RoleDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDetailsDTO[]>(<any>null);
    }

    /**
     * @param searchText (optional) 
     * @param take (optional) 
     * @return Success
     */
    apiRolesGetRoleLookupsGet(searchText: string, take: number): Observable<RoleDTO[]> {
        let url_ = this.baseUrl + "/api/Roles/GetRoleLookups?";
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesGetRoleLookupsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesGetRoleLookupsGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesGetRoleLookupsGet(response: HttpResponseBase): Observable<RoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO[]>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiRolesGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<RoleDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Roles/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesGetAllGet(response: HttpResponseBase): Observable<RoleDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDTODataSourceResult.fromJS(resultData200) : new RoleDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiRolesGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<RoleDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Roles/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesGetAllDetailsGet(response: HttpResponseBase): Observable<RoleDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDTODataSourceResult.fromJS(resultData200) : new RoleDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiRolesGetByIdGet(id: number): Observable<RoleDTO> {
        let url_ = this.baseUrl + "/api/Roles/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesGetByIdGet(response: HttpResponseBase): Observable<RoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDTO.fromJS(resultData200) : new RoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiRolesInsertPost(body: RoleDTO[]): Observable<RoleDTO[]> {
        let url_ = this.baseUrl + "/api/Roles/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesInsertPost(response: HttpResponseBase): Observable<RoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiRolesUpdatePut(body: RoleDTO[]): Observable<RoleDTO[]> {
        let url_ = this.baseUrl + "/api/Roles/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesUpdatePut(response: HttpResponseBase): Observable<RoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiRolesDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Roles/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiRolesIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Roles/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiRolesIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiRolesIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiRolesIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiTourAgentsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourAgentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/TourAgents/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourAgentsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourAgentsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<TourAgentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourAgentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourAgentsGetAllGet(response: HttpResponseBase): Observable<TourAgentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourAgentDTODataSourceResult.fromJS(resultData200) : new TourAgentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourAgentDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiTourAgentsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourAgentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/TourAgents/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourAgentsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourAgentsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<TourAgentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourAgentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourAgentsGetAllDetailsGet(response: HttpResponseBase): Observable<TourAgentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourAgentDTODataSourceResult.fromJS(resultData200) : new TourAgentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourAgentDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiTourAgentsGetByIdGet(id: number): Observable<TourAgentDTO> {
        let url_ = this.baseUrl + "/api/TourAgents/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourAgentsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourAgentsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<TourAgentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourAgentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourAgentsGetByIdGet(response: HttpResponseBase): Observable<TourAgentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourAgentDTO.fromJS(resultData200) : new TourAgentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourAgentDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourAgentsInsertPost(body: TourAgentDTO[]): Observable<TourAgentDTO[]> {
        let url_ = this.baseUrl + "/api/TourAgents/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourAgentsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourAgentsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<TourAgentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourAgentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourAgentsInsertPost(response: HttpResponseBase): Observable<TourAgentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourAgentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourAgentDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourAgentsUpdatePut(body: TourAgentDTO[]): Observable<TourAgentDTO[]> {
        let url_ = this.baseUrl + "/api/TourAgents/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourAgentsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourAgentsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<TourAgentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourAgentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourAgentsUpdatePut(response: HttpResponseBase): Observable<TourAgentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourAgentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourAgentDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiTourAgentsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/TourAgents/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourAgentsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourAgentsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourAgentsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourAgentsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TourAgents/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourAgentsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourAgentsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourAgentsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourCheckPointsScanLocationQrCodePost(body: LocationQrCodeDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/ScanLocationQrCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsScanLocationQrCodePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsScanLocationQrCodePost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsScanLocationQrCodePost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tourCheckPointId (optional) 
     * @param state (optional) 
     * @return Success
     */
    apiTourCheckPointsCompleteTourCheckPointGet(tourCheckPointId: number, state: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/CompleteTourCheckPoint?";
        if (tourCheckPointId !== undefined)
            url_ += "TourCheckPointId=" + encodeURIComponent("" + tourCheckPointId) + "&"; 
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsCompleteTourCheckPointGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsCompleteTourCheckPointGet(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsCompleteTourCheckPointGet(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    apiTourCheckPointsAddCheckPointTourCommentPost(): Observable<CommentDTO> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/AddCheckPointTourComment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsAddCheckPointTourCommentPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsAddCheckPointTourCommentPost(<any>response_);
                } catch (e) {
                    return <Observable<CommentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsAddCheckPointTourCommentPost(response: HttpResponseBase): Observable<CommentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDTO.fromJS(resultData200) : new CommentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiTourCheckPointsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourCheckPointDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCheckPointDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCheckPointDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsGetAllGet(response: HttpResponseBase): Observable<TourCheckPointDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCheckPointDTODataSourceResult.fromJS(resultData200) : new TourCheckPointDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCheckPointDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiTourCheckPointsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourCheckPointDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCheckPointDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCheckPointDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsGetAllDetailsGet(response: HttpResponseBase): Observable<TourCheckPointDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCheckPointDTODataSourceResult.fromJS(resultData200) : new TourCheckPointDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCheckPointDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiTourCheckPointsGetByIdGet(id: number): Observable<TourCheckPointDTO> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCheckPointDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCheckPointDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsGetByIdGet(response: HttpResponseBase): Observable<TourCheckPointDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCheckPointDTO.fromJS(resultData200) : new TourCheckPointDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCheckPointDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourCheckPointsInsertPost(body: TourCheckPointDTO[]): Observable<TourCheckPointDTO[]> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<TourCheckPointDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCheckPointDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsInsertPost(response: HttpResponseBase): Observable<TourCheckPointDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourCheckPointDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCheckPointDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourCheckPointsUpdatePut(body: TourCheckPointDTO[]): Observable<TourCheckPointDTO[]> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<TourCheckPointDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCheckPointDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsUpdatePut(response: HttpResponseBase): Observable<TourCheckPointDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourCheckPointDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCheckPointDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiTourCheckPointsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourCheckPointsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TourCheckPoints/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCheckPointsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCheckPointsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCheckPointsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiTourCommentsGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourCommentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/TourComments/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCommentsGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCommentsGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCommentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCommentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCommentsGetAllGet(response: HttpResponseBase): Observable<TourCommentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCommentDTODataSourceResult.fromJS(resultData200) : new TourCommentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCommentDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiTourCommentsGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourCommentDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/TourComments/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCommentsGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCommentsGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCommentDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCommentDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCommentsGetAllDetailsGet(response: HttpResponseBase): Observable<TourCommentDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCommentDTODataSourceResult.fromJS(resultData200) : new TourCommentDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCommentDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiTourCommentsGetByIdGet(id: number): Observable<TourCommentDTO> {
        let url_ = this.baseUrl + "/api/TourComments/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCommentsGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCommentsGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCommentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCommentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCommentsGetByIdGet(response: HttpResponseBase): Observable<TourCommentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCommentDTO.fromJS(resultData200) : new TourCommentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCommentDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourCommentsInsertPost(body: TourCommentDTO[]): Observable<TourCommentDTO[]> {
        let url_ = this.baseUrl + "/api/TourComments/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCommentsInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCommentsInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<TourCommentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCommentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCommentsInsertPost(response: HttpResponseBase): Observable<TourCommentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourCommentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCommentDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourCommentsUpdatePut(body: TourCommentDTO[]): Observable<TourCommentDTO[]> {
        let url_ = this.baseUrl + "/api/TourComments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCommentsUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCommentsUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<TourCommentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCommentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCommentsUpdatePut(response: HttpResponseBase): Observable<TourCommentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourCommentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCommentDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiTourCommentsDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/TourComments/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCommentsDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCommentsDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCommentsDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiTourCommentsIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TourComments/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTourCommentsIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTourCommentsIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiTourCommentsIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param lat (optional) 
     * @param longs (optional) 
     * @return Success
     */
    apiToursGetTodayToursGet(lat: number, longs: number): Observable<HomeTourDTO[]> {
        let url_ = this.baseUrl + "/api/Tours/GetTodayTours?";
        if (lat !== undefined)
            url_ += "lat=" + encodeURIComponent("" + lat) + "&"; 
        if (longs !== undefined)
            url_ += "longs=" + encodeURIComponent("" + longs) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetTodayToursGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetTodayToursGet(<any>response_);
                } catch (e) {
                    return <Observable<HomeTourDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HomeTourDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetTodayToursGet(response: HttpResponseBase): Observable<HomeTourDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HomeTourDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeTourDTO[]>(<any>null);
    }

    /**
     * @param lat (optional) 
     * @param longs (optional) 
     * @return Success
     */
    apiToursGetTourHistoryGet(lat: number, longs: number): Observable<HomeTourDTO[]> {
        let url_ = this.baseUrl + "/api/Tours/GetTourHistory?";
        if (lat !== undefined)
            url_ += "lat=" + encodeURIComponent("" + lat) + "&"; 
        if (longs !== undefined)
            url_ += "longs=" + encodeURIComponent("" + longs) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetTourHistoryGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetTourHistoryGet(<any>response_);
                } catch (e) {
                    return <Observable<HomeTourDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HomeTourDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetTourHistoryGet(response: HttpResponseBase): Observable<HomeTourDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HomeTourDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeTourDTO[]>(<any>null);
    }

    /**
     * @param tourId (optional) 
     * @return Success
     */
    apiToursGetTourPointsGet(tourId: number): Observable<TourCheckpointDetailsDTO> {
        let url_ = this.baseUrl + "/api/Tours/GetTourPoints?";
        if (tourId !== undefined)
            url_ += "tourId=" + encodeURIComponent("" + tourId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetTourPointsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetTourPointsGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCheckpointDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCheckpointDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetTourPointsGet(response: HttpResponseBase): Observable<TourCheckpointDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCheckpointDetailsDTO.fromJS(resultData200) : new TourCheckpointDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCheckpointDetailsDTO>(<any>null);
    }

    /**
     * @param tourId (optional) 
     * @return Success
     */
    apiToursGetAdminCommentsGet(tourId: number): Observable<TourCommentDTO[]> {
        let url_ = this.baseUrl + "/api/Tours/GetAdminComments?";
        if (tourId !== undefined)
            url_ += "tourId=" + encodeURIComponent("" + tourId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetAdminCommentsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetAdminCommentsGet(<any>response_);
                } catch (e) {
                    return <Observable<TourCommentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCommentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetAdminCommentsGet(response: HttpResponseBase): Observable<TourCommentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourCommentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCommentDTO[]>(<any>null);
    }

    /**
     * @param tourId (optional) 
     * @param state (optional) 
     * @return Success
     */
    apiToursChangeTourStateGet(tourId: number, state: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tours/ChangeTourState?";
        if (tourId !== undefined)
            url_ += "TourId=" + encodeURIComponent("" + tourId) + "&"; 
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursChangeTourStateGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursChangeTourStateGet(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursChangeTourStateGet(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param searchText (optional) 
     * @param take (optional) 
     * @return Success
     */
    apiToursGetTemplatesGet(searchText: string, take: number): Observable<TourTemplateDTO[]> {
        let url_ = this.baseUrl + "/api/Tours/GetTemplates?";
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetTemplatesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetTemplatesGet(<any>response_);
                } catch (e) {
                    return <Observable<TourTemplateDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourTemplateDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetTemplatesGet(response: HttpResponseBase): Observable<TourTemplateDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourTemplateDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourTemplateDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiToursInsertTourPost(body: TourCreateDTO): Observable<TourCreateDTO> {
        let url_ = this.baseUrl + "/api/Tours/InsertTour";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursInsertTourPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursInsertTourPost(<any>response_);
                } catch (e) {
                    return <Observable<TourCreateDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourCreateDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursInsertTourPost(response: HttpResponseBase): Observable<TourCreateDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourCreateDTO.fromJS(resultData200) : new TourCreateDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourCreateDTO>(<any>null);
    }

    /**
     * @param tourId (optional) 
     * @param state (optional) 
     * @return Success
     */
    apiToursActiveDisActiveTemplateGet(tourId: number, state: boolean): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tours/ActiveDisActiveTemplate?";
        if (tourId !== undefined)
            url_ += "tourId=" + encodeURIComponent("" + tourId) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursActiveDisActiveTemplateGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursActiveDisActiveTemplateGet(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursActiveDisActiveTemplateGet(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiToursGetAllGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Tours/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetAllGet(<any>response_);
                } catch (e) {
                    return <Observable<TourDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetAllGet(response: HttpResponseBase): Observable<TourDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourDTODataSourceResult.fromJS(resultData200) : new TourDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourDTODataSourceResult>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    apiToursGetAllDetailsGet(take: number, skip: number, sort: Sort[], filter_Field: string, filter_Operator: string, filter_Value: string, filter_Logic: string, filter_Filters: Filter[], countless: boolean): Observable<TourDTODataSourceResult> {
        let url_ = this.baseUrl + "/api/Tours/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetAllDetailsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetAllDetailsGet(<any>response_);
                } catch (e) {
                    return <Observable<TourDTODataSourceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourDTODataSourceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetAllDetailsGet(response: HttpResponseBase): Observable<TourDTODataSourceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourDTODataSourceResult.fromJS(resultData200) : new TourDTODataSourceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourDTODataSourceResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiToursGetByIdGet(id: number): Observable<TourDTO> {
        let url_ = this.baseUrl + "/api/Tours/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursGetByIdGet(<any>response_);
                } catch (e) {
                    return <Observable<TourDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursGetByIdGet(response: HttpResponseBase): Observable<TourDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TourDTO.fromJS(resultData200) : new TourDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourDTO>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiToursInsertPost(body: TourDTO[]): Observable<TourDTO[]> {
        let url_ = this.baseUrl + "/api/Tours/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursInsertPost(<any>response_);
                } catch (e) {
                    return <Observable<TourDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursInsertPost(response: HttpResponseBase): Observable<TourDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiToursUpdatePut(body: TourDTO[]): Observable<TourDTO[]> {
        let url_ = this.baseUrl + "/api/Tours/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursUpdatePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursUpdatePut(<any>response_);
                } catch (e) {
                    return <Observable<TourDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TourDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursUpdatePut(response: HttpResponseBase): Observable<TourDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TourDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TourDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiToursDeleteDelete(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Tours/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursDeleteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursDeleteDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursDeleteDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiToursIsExistedPost(body: CheckUniqueDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tours/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiToursIsExistedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiToursIsExistedPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApiToursIsExistedPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class UserLoginModel implements IUserLoginModel {
    username: string;
    password: string;
    applicationType?: string;
    continue?: boolean;
    disableSSO?: boolean;

    constructor(data?: IUserLoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
            this.applicationType = data["applicationType"];
            this.continue = data["continue"];
            this.disableSSO = data["disableSSO"];
        }
    }

    static fromJS(data: any): UserLoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["applicationType"] = this.applicationType;
        data["continue"] = this.continue;
        data["disableSSO"] = this.disableSSO;
        return data; 
    }
}

export interface IUserLoginModel {
    username: string;
    password: string;
    applicationType?: string;
    continue?: boolean;
    disableSSO?: boolean;
}

export class AccessToken implements IAccessToken {
    access_token?: string;
    refresh_token?: string;
    is_ldap_auth?: boolean;
    is_mobile?: boolean;
    is_vip?: boolean;
    is_factor_auth?: boolean;
    isLocked?: boolean;
    isTemp?: boolean;
    isAdmin?: boolean;
    userTN?: string;
    userTP?: string;
    responseMessage?: string;
    signature_factor_auth?: boolean;
    erP_EmployeeNumber?: string;

    constructor(data?: IAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.access_token = data["access_token"];
            this.refresh_token = data["refresh_token"];
            this.is_ldap_auth = data["is_ldap_auth"];
            this.is_mobile = data["is_mobile"];
            this.is_vip = data["is_vip"];
            this.is_factor_auth = data["is_factor_auth"];
            this.isLocked = data["isLocked"];
            this.isTemp = data["isTemp"];
            this.isAdmin = data["isAdmin"];
            this.userTN = data["userTN"];
            this.userTP = data["userTP"];
            this.responseMessage = data["responseMessage"];
            this.signature_factor_auth = data["signature_factor_auth"];
            this.erP_EmployeeNumber = data["erP_EmployeeNumber"];
        }
    }

    static fromJS(data: any): AccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new AccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        data["is_ldap_auth"] = this.is_ldap_auth;
        data["is_mobile"] = this.is_mobile;
        data["is_vip"] = this.is_vip;
        data["is_factor_auth"] = this.is_factor_auth;
        data["isLocked"] = this.isLocked;
        data["isTemp"] = this.isTemp;
        data["isAdmin"] = this.isAdmin;
        data["userTN"] = this.userTN;
        data["userTP"] = this.userTP;
        data["responseMessage"] = this.responseMessage;
        data["signature_factor_auth"] = this.signature_factor_auth;
        data["erP_EmployeeNumber"] = this.erP_EmployeeNumber;
        return data; 
    }
}

export interface IAccessToken {
    access_token?: string;
    refresh_token?: string;
    is_ldap_auth?: boolean;
    is_mobile?: boolean;
    is_vip?: boolean;
    is_factor_auth?: boolean;
    isLocked?: boolean;
    isTemp?: boolean;
    isAdmin?: boolean;
    userTN?: string;
    userTP?: string;
    responseMessage?: string;
    signature_factor_auth?: boolean;
    erP_EmployeeNumber?: string;
}

export enum AgentType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class CompanyDTO implements ICompanyDTO {
    id?: number;
    companyNameAr?: string;
    companyNameEn?: string;
    companyEmail?: string;
    companyImageUrl?: string;
    phone?: string;
    vaildFrom?: Date;
    vaildTo?: Date;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.companyNameAr = data["companyNameAr"];
            this.companyNameEn = data["companyNameEn"];
            this.companyEmail = data["companyEmail"];
            this.companyImageUrl = data["companyImageUrl"];
            this.phone = data["phone"];
            this.vaildFrom = data["vaildFrom"] ? new Date(data["vaildFrom"].toString()) : <any>undefined;
            this.vaildTo = data["vaildTo"] ? new Date(data["vaildTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyNameAr"] = this.companyNameAr;
        data["companyNameEn"] = this.companyNameEn;
        data["companyEmail"] = this.companyEmail;
        data["companyImageUrl"] = this.companyImageUrl;
        data["phone"] = this.phone;
        data["vaildFrom"] = this.vaildFrom ? this.vaildFrom.toISOString() : <any>undefined;
        data["vaildTo"] = this.vaildTo ? this.vaildTo.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICompanyDTO {
    id?: number;
    companyNameAr?: string;
    companyNameEn?: string;
    companyEmail?: string;
    companyImageUrl?: string;
    phone?: string;
    vaildFrom?: Date;
    vaildTo?: Date;
}

export class AgentDTO implements IAgentDTO {
    id?: string;
    userName?: string;
    password?: string;
    email?: string;
    jobTitle?: string;
    mobile?: string;
    birthDate?: Date;
    fullNameAr?: string;
    fullNameEn?: string;
    image?: string;
    agentType?: AgentType;
    active?: boolean;
    tempPassword?: boolean;
    supervisorId?: string;
    supervisor?: AgentDTO;
    agents?: AgentDTO[];
    companyId?: number;
    company?: CompanyDTO;
    agentRoles?: AgentRoleDTO[];

    constructor(data?: IAgentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.password = data["password"];
            this.email = data["email"];
            this.jobTitle = data["jobTitle"];
            this.mobile = data["mobile"];
            this.birthDate = data["birthDate"] ? new Date(data["birthDate"].toString()) : <any>undefined;
            this.fullNameAr = data["fullNameAr"];
            this.fullNameEn = data["fullNameEn"];
            this.image = data["image"];
            this.agentType = data["agentType"];
            this.active = data["active"];
            this.tempPassword = data["tempPassword"];
            this.supervisorId = data["supervisorId"];
            this.supervisor = data["supervisor"] ? AgentDTO.fromJS(data["supervisor"]) : <any>undefined;
            if (data["agents"] && data["agents"].constructor === Array) {
                this.agents = [];
                for (let item of data["agents"])
                    this.agents.push(AgentDTO.fromJS(item));
            }
            this.companyId = data["companyId"];
            this.company = data["company"] ? CompanyDTO.fromJS(data["company"]) : <any>undefined;
            if (data["agentRoles"] && data["agentRoles"].constructor === Array) {
                this.agentRoles = [];
                for (let item of data["agentRoles"])
                    this.agentRoles.push(AgentRoleDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["jobTitle"] = this.jobTitle;
        data["mobile"] = this.mobile;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["fullNameAr"] = this.fullNameAr;
        data["fullNameEn"] = this.fullNameEn;
        data["image"] = this.image;
        data["agentType"] = this.agentType;
        data["active"] = this.active;
        data["tempPassword"] = this.tempPassword;
        data["supervisorId"] = this.supervisorId;
        data["supervisor"] = this.supervisor ? this.supervisor.toJSON() : <any>undefined;
        if (this.agents && this.agents.constructor === Array) {
            data["agents"] = [];
            for (let item of this.agents)
                data["agents"].push(item.toJSON());
        }
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (this.agentRoles && this.agentRoles.constructor === Array) {
            data["agentRoles"] = [];
            for (let item of this.agentRoles)
                data["agentRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAgentDTO {
    id?: string;
    userName?: string;
    password?: string;
    email?: string;
    jobTitle?: string;
    mobile?: string;
    birthDate?: Date;
    fullNameAr?: string;
    fullNameEn?: string;
    image?: string;
    agentType?: AgentType;
    active?: boolean;
    tempPassword?: boolean;
    supervisorId?: string;
    supervisor?: AgentDTO;
    agents?: AgentDTO[];
    companyId?: number;
    company?: CompanyDTO;
    agentRoles?: AgentRoleDTO[];
}

export class PermissionDTO implements IPermissionDTO {
    id?: number;
    permissionNameAr?: string;
    permissionNameEn?: string;
    permissionKey?: string;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.permissionNameAr = data["permissionNameAr"];
            this.permissionNameEn = data["permissionNameEn"];
            this.permissionKey = data["permissionKey"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionNameAr"] = this.permissionNameAr;
        data["permissionNameEn"] = this.permissionNameEn;
        data["permissionKey"] = this.permissionKey;
        return data; 
    }
}

export interface IPermissionDTO {
    id?: number;
    permissionNameAr?: string;
    permissionNameEn?: string;
    permissionKey?: string;
}

export class RolePermissionDTO implements IRolePermissionDTO {
    id?: number;
    roleId?: number;
    role?: RoleDTO;
    permissionId?: number;
    permission?: PermissionDTO;

    constructor(data?: IRolePermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.role = data["role"] ? RoleDTO.fromJS(data["role"]) : <any>undefined;
            this.permissionId = data["permissionId"];
            this.permission = data["permission"] ? PermissionDTO.fromJS(data["permission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RolePermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["permissionId"] = this.permissionId;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRolePermissionDTO {
    id?: number;
    roleId?: number;
    role?: RoleDTO;
    permissionId?: number;
    permission?: PermissionDTO;
}

export class RoleDTO implements IRoleDTO {
    id?: number;
    roleNameAr?: string;
    roleNameEn?: string;
    permissions?: RolePermissionDTO[];

    constructor(data?: IRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleNameAr = data["roleNameAr"];
            this.roleNameEn = data["roleNameEn"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(RolePermissionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleNameAr"] = this.roleNameAr;
        data["roleNameEn"] = this.roleNameEn;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoleDTO {
    id?: number;
    roleNameAr?: string;
    roleNameEn?: string;
    permissions?: RolePermissionDTO[];
}

export class AgentRoleDTO implements IAgentRoleDTO {
    id?: number;
    agentId?: string;
    agent?: AgentDTO;
    roleId?: number;
    role?: RoleDTO;

    constructor(data?: IAgentRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.agentId = data["agentId"];
            this.agent = data["agent"] ? AgentDTO.fromJS(data["agent"]) : <any>undefined;
            this.roleId = data["roleId"];
            this.role = data["role"] ? RoleDTO.fromJS(data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AgentRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgentRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["agentId"] = this.agentId;
        data["agent"] = this.agent ? this.agent.toJSON() : <any>undefined;
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAgentRoleDTO {
    id?: number;
    agentId?: string;
    agent?: AgentDTO;
    roleId?: number;
    role?: RoleDTO;
}

export class AuthTicketDTO implements IAuthTicketDTO {
    userName?: string;
    email?: string;
    fullName?: string;
    fullNameAr?: string;
    image?: string;
    lastLoginDate?: Date;
    fullNameEn?: string;
    userId?: string;
    jobTitle?: string;
    mobile?: string;
    birthDate?: Date;
    supervisorId?: string;
    companyId?: number;
    agentRoles?: AgentRoleDTO[];

    constructor(data?: IAuthTicketDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.email = data["email"];
            this.fullName = data["fullName"];
            this.fullNameAr = data["fullNameAr"];
            this.image = data["image"];
            this.lastLoginDate = data["lastLoginDate"] ? new Date(data["lastLoginDate"].toString()) : <any>undefined;
            this.fullNameEn = data["fullNameEn"];
            this.userId = data["userId"];
            this.jobTitle = data["jobTitle"];
            this.mobile = data["mobile"];
            this.birthDate = data["birthDate"] ? new Date(data["birthDate"].toString()) : <any>undefined;
            this.supervisorId = data["supervisorId"];
            this.companyId = data["companyId"];
            if (data["agentRoles"] && data["agentRoles"].constructor === Array) {
                this.agentRoles = [];
                for (let item of data["agentRoles"])
                    this.agentRoles.push(AgentRoleDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthTicketDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTicketDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["fullNameAr"] = this.fullNameAr;
        data["image"] = this.image;
        data["lastLoginDate"] = this.lastLoginDate ? this.lastLoginDate.toISOString() : <any>undefined;
        data["fullNameEn"] = this.fullNameEn;
        data["userId"] = this.userId;
        data["jobTitle"] = this.jobTitle;
        data["mobile"] = this.mobile;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["supervisorId"] = this.supervisorId;
        data["companyId"] = this.companyId;
        if (this.agentRoles && this.agentRoles.constructor === Array) {
            data["agentRoles"] = [];
            for (let item of this.agentRoles)
                data["agentRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuthTicketDTO {
    userName?: string;
    email?: string;
    fullName?: string;
    fullNameAr?: string;
    image?: string;
    lastLoginDate?: Date;
    fullNameEn?: string;
    userId?: string;
    jobTitle?: string;
    mobile?: string;
    birthDate?: Date;
    supervisorId?: string;
    companyId?: number;
    agentRoles?: AgentRoleDTO[];
}

export class MessageDTO implements IMessageDTO {
    id?: number;
    fullName?: string;
    mobile?: string;
    email?: string;
    message?: string;

    constructor(data?: IMessageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.mobile = data["mobile"];
            this.email = data["email"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): MessageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["message"] = this.message;
        return data; 
    }
}

export interface IMessageDTO {
    id?: number;
    fullName?: string;
    mobile?: string;
    email?: string;
    message?: string;
}

export class AgentDetailsDTO implements IAgentDetailsDTO {
    id?: string;
    email?: string;
    jobTitle?: string;
    mobile?: string;
    birthDate?: Date;
    fullNameAr?: string;
    fullNameEn?: string;

    constructor(data?: IAgentDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.email = data["email"];
            this.jobTitle = data["jobTitle"];
            this.mobile = data["mobile"];
            this.birthDate = data["birthDate"] ? new Date(data["birthDate"].toString()) : <any>undefined;
            this.fullNameAr = data["fullNameAr"];
            this.fullNameEn = data["fullNameEn"];
        }
    }

    static fromJS(data: any): AgentDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgentDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["jobTitle"] = this.jobTitle;
        data["mobile"] = this.mobile;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["fullNameAr"] = this.fullNameAr;
        data["fullNameEn"] = this.fullNameEn;
        return data; 
    }
}

export interface IAgentDetailsDTO {
    id?: string;
    email?: string;
    jobTitle?: string;
    mobile?: string;
    birthDate?: Date;
    fullNameAr?: string;
    fullNameEn?: string;
}

export class Sort implements ISort {
    field?: string;
    dir?: string;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.dir = data["dir"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["dir"] = this.dir;
        return data; 
    }
}

export interface ISort {
    field?: string;
    dir?: string;
}

export class Filter implements IFilter {
    field?: string;
    operator?: string;
    value?: string;
    logic?: string;
    filters?: Filter[];

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.operator = data["operator"];
            this.value = data["value"];
            this.logic = data["logic"];
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(Filter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["operator"] = this.operator;
        data["value"] = this.value;
        data["logic"] = this.logic;
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFilter {
    field?: string;
    operator?: string;
    value?: string;
    logic?: string;
    filters?: Filter[];
}

export class AgentLocationLogDTO implements IAgentLocationLogDTO {
    id?: number;
    agentId?: string;
    lat?: number;
    long?: number;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: IAgentLocationLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.agentId = data["agentId"];
            this.lat = data["lat"];
            this.long = data["long"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AgentLocationLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgentLocationLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["agentId"] = this.agentId;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAgentLocationLogDTO {
    id?: number;
    agentId?: string;
    lat?: number;
    long?: number;
    createdBy?: string;
    createdOn?: Date;
}

export class AgentLocationLogDTODataSourceResult implements IAgentLocationLogDTODataSourceResult {
    data?: AgentLocationLogDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: IAgentLocationLogDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AgentLocationLogDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): AgentLocationLogDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new AgentLocationLogDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface IAgentLocationLogDTODataSourceResult {
    data?: AgentLocationLogDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class CheckUniqueDTO implements ICheckUniqueDTO {
    tableName?: string;
    fields?: string[];
    values?: string[];

    constructor(data?: ICheckUniqueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tableName = data["tableName"];
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(item);
            }
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
        }
    }

    static fromJS(data: any): CheckUniqueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUniqueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface ICheckUniqueDTO {
    tableName?: string;
    fields?: string[];
    values?: string[];
}

export class AgentLoginLogDTO implements IAgentLoginLogDTO {
    id?: number;
    accessToken?: string;
    macId?: string;
    mobileType?: string;
    network?: string;
    serailNumber?: string;
    agentId?: string;
    agent?: AgentDTO;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: IAgentLoginLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.accessToken = data["accessToken"];
            this.macId = data["macId"];
            this.mobileType = data["mobileType"];
            this.network = data["network"];
            this.serailNumber = data["serailNumber"];
            this.agentId = data["agentId"];
            this.agent = data["agent"] ? AgentDTO.fromJS(data["agent"]) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AgentLoginLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgentLoginLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accessToken"] = this.accessToken;
        data["macId"] = this.macId;
        data["mobileType"] = this.mobileType;
        data["network"] = this.network;
        data["serailNumber"] = this.serailNumber;
        data["agentId"] = this.agentId;
        data["agent"] = this.agent ? this.agent.toJSON() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAgentLoginLogDTO {
    id?: number;
    accessToken?: string;
    macId?: string;
    mobileType?: string;
    network?: string;
    serailNumber?: string;
    agentId?: string;
    agent?: AgentDTO;
    createdBy?: string;
    createdOn?: Date;
}

export class AgentLoginLogDTODataSourceResult implements IAgentLoginLogDTODataSourceResult {
    data?: AgentLoginLogDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: IAgentLoginLogDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AgentLoginLogDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): AgentLoginLogDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new AgentLoginLogDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface IAgentLoginLogDTODataSourceResult {
    data?: AgentLoginLogDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class AgentRoleDTODataSourceResult implements IAgentRoleDTODataSourceResult {
    data?: AgentRoleDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: IAgentRoleDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AgentRoleDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): AgentRoleDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new AgentRoleDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface IAgentRoleDTODataSourceResult {
    data?: AgentRoleDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class AgentDTODataSourceResult implements IAgentDTODataSourceResult {
    data?: AgentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: IAgentDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AgentDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): AgentDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new AgentDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface IAgentDTODataSourceResult {
    data?: AgentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export enum AttachmentType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class AttachmentDTO implements IAttachmentDTO {
    id?: number;
    attachmentName?: string;
    attachmentType?: AttachmentType;
    attachmentUrl?: string;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: IAttachmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.attachmentName = data["attachmentName"];
            this.attachmentType = data["attachmentType"];
            this.attachmentUrl = data["attachmentUrl"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AttachmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attachmentName"] = this.attachmentName;
        data["attachmentType"] = this.attachmentType;
        data["attachmentUrl"] = this.attachmentUrl;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAttachmentDTO {
    id?: number;
    attachmentName?: string;
    attachmentType?: AttachmentType;
    attachmentUrl?: string;
    createdBy?: string;
    createdOn?: Date;
}

export class AttachmentDTODataSourceResult implements IAttachmentDTODataSourceResult {
    data?: AttachmentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: IAttachmentDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AttachmentDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): AttachmentDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface IAttachmentDTODataSourceResult {
    data?: AttachmentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class CheckPointDTO implements ICheckPointDTO {
    id?: number;
    checkPointNameAr?: string;
    checkPointNameEn?: string;
    lat?: number;
    long?: number;
    locationText?: string;
    qrCode?: string;

    constructor(data?: ICheckPointDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.checkPointNameAr = data["checkPointNameAr"];
            this.checkPointNameEn = data["checkPointNameEn"];
            this.lat = data["lat"];
            this.long = data["long"];
            this.locationText = data["locationText"];
            this.qrCode = data["qrCode"];
        }
    }

    static fromJS(data: any): CheckPointDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPointDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkPointNameAr"] = this.checkPointNameAr;
        data["checkPointNameEn"] = this.checkPointNameEn;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["locationText"] = this.locationText;
        data["qrCode"] = this.qrCode;
        return data; 
    }
}

export interface ICheckPointDTO {
    id?: number;
    checkPointNameAr?: string;
    checkPointNameEn?: string;
    lat?: number;
    long?: number;
    locationText?: string;
    qrCode?: string;
}

export class CheckPointDTODataSourceResult implements ICheckPointDTODataSourceResult {
    data?: CheckPointDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ICheckPointDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CheckPointDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): CheckPointDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPointDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ICheckPointDTODataSourceResult {
    data?: CheckPointDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class TourDTO implements ITourDTO {
    id?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: ITourDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourNameAr = data["tourNameAr"];
            this.tourNameEn = data["tourNameEn"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TourDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourNameAr"] = this.tourNameAr;
        data["tourNameEn"] = this.tourNameEn;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITourDTO {
    id?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    createdBy?: string;
    createdOn?: Date;
}

export enum TourType {
    _1 = 1, 
    _2 = 2, 
}

export enum TourState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
}

export class TourStateLogDTO implements ITourStateLogDTO {
    id?: number;
    tourId?: number;
    tour?: TourAgentDTO;
    tourState?: TourState;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: ITourStateLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourId = data["tourId"];
            this.tour = data["tour"] ? TourAgentDTO.fromJS(data["tour"]) : <any>undefined;
            this.tourState = data["tourState"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TourStateLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourStateLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourId"] = this.tourId;
        data["tour"] = this.tour ? this.tour.toJSON() : <any>undefined;
        data["tourState"] = this.tourState;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITourStateLogDTO {
    id?: number;
    tourId?: number;
    tour?: TourAgentDTO;
    tourState?: TourState;
    createdBy?: string;
    createdOn?: Date;
}

export class CommentDTO implements ICommentDTO {
    id?: number;
    text?: string;
    attachmentId?: number;
    attachment?: AttachmentDTO;
    replayToComment?: number;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: ICommentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            this.attachmentId = data["attachmentId"];
            this.attachment = data["attachment"] ? AttachmentDTO.fromJS(data["attachment"]) : <any>undefined;
            this.replayToComment = data["replayToComment"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["attachmentId"] = this.attachmentId;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["replayToComment"] = this.replayToComment;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICommentDTO {
    id?: number;
    text?: string;
    attachmentId?: number;
    attachment?: AttachmentDTO;
    replayToComment?: number;
    createdBy?: string;
    createdOn?: Date;
}

export class TourCommentDTO implements ITourCommentDTO {
    id?: number;
    tourId?: number;
    tour?: TourAgentDTO;
    commentId?: number;
    comment?: CommentDTO;
    createdBy?: string;
    createdOn?: Date;
    createdByUser?: AgentDTO;

    constructor(data?: ITourCommentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourId = data["tourId"];
            this.tour = data["tour"] ? TourAgentDTO.fromJS(data["tour"]) : <any>undefined;
            this.commentId = data["commentId"];
            this.comment = data["comment"] ? CommentDTO.fromJS(data["comment"]) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
            this.createdByUser = data["createdByUser"] ? AgentDTO.fromJS(data["createdByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TourCommentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourCommentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourId"] = this.tourId;
        data["tour"] = this.tour ? this.tour.toJSON() : <any>undefined;
        data["commentId"] = this.commentId;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITourCommentDTO {
    id?: number;
    tourId?: number;
    tour?: TourAgentDTO;
    commentId?: number;
    comment?: CommentDTO;
    createdBy?: string;
    createdOn?: Date;
    createdByUser?: AgentDTO;
}

export class TourAgentDTO implements ITourAgentDTO {
    id?: number;
    tourId?: number;
    tour?: TourDTO;
    tourDate?: Date;
    tourType?: TourType;
    checkPoints?: TourCheckPointDTO[];
    agentId?: string;
    agent?: AgentDTO;
    tourState?: TourState;
    estimatedDistance?: number;
    estimatedEndDate?: Date;
    tourStateLogs?: TourStateLogDTO[];
    comments?: TourCommentDTO[];

    constructor(data?: ITourAgentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourId = data["tourId"];
            this.tour = data["tour"] ? TourDTO.fromJS(data["tour"]) : <any>undefined;
            this.tourDate = data["tourDate"] ? new Date(data["tourDate"].toString()) : <any>undefined;
            this.tourType = data["tourType"];
            if (data["checkPoints"] && data["checkPoints"].constructor === Array) {
                this.checkPoints = [];
                for (let item of data["checkPoints"])
                    this.checkPoints.push(TourCheckPointDTO.fromJS(item));
            }
            this.agentId = data["agentId"];
            this.agent = data["agent"] ? AgentDTO.fromJS(data["agent"]) : <any>undefined;
            this.tourState = data["tourState"];
            this.estimatedDistance = data["estimatedDistance"];
            this.estimatedEndDate = data["estimatedEndDate"] ? new Date(data["estimatedEndDate"].toString()) : <any>undefined;
            if (data["tourStateLogs"] && data["tourStateLogs"].constructor === Array) {
                this.tourStateLogs = [];
                for (let item of data["tourStateLogs"])
                    this.tourStateLogs.push(TourStateLogDTO.fromJS(item));
            }
            if (data["comments"] && data["comments"].constructor === Array) {
                this.comments = [];
                for (let item of data["comments"])
                    this.comments.push(TourCommentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TourAgentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourAgentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourId"] = this.tourId;
        data["tour"] = this.tour ? this.tour.toJSON() : <any>undefined;
        data["tourDate"] = this.tourDate ? this.tourDate.toISOString() : <any>undefined;
        data["tourType"] = this.tourType;
        if (this.checkPoints && this.checkPoints.constructor === Array) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        data["agentId"] = this.agentId;
        data["agent"] = this.agent ? this.agent.toJSON() : <any>undefined;
        data["tourState"] = this.tourState;
        data["estimatedDistance"] = this.estimatedDistance;
        data["estimatedEndDate"] = this.estimatedEndDate ? this.estimatedEndDate.toISOString() : <any>undefined;
        if (this.tourStateLogs && this.tourStateLogs.constructor === Array) {
            data["tourStateLogs"] = [];
            for (let item of this.tourStateLogs)
                data["tourStateLogs"].push(item.toJSON());
        }
        if (this.comments && this.comments.constructor === Array) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITourAgentDTO {
    id?: number;
    tourId?: number;
    tour?: TourDTO;
    tourDate?: Date;
    tourType?: TourType;
    checkPoints?: TourCheckPointDTO[];
    agentId?: string;
    agent?: AgentDTO;
    tourState?: TourState;
    estimatedDistance?: number;
    estimatedEndDate?: Date;
    tourStateLogs?: TourStateLogDTO[];
    comments?: TourCommentDTO[];
}

export enum TourCheckPointState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export class TourCheckPointDTO implements ITourCheckPointDTO {
    id?: number;
    tourId?: number;
    tour?: TourAgentDTO;
    checkPointId?: number;
    checkPoint?: CheckPointDTO;
    checkPointTourComments?: CheckPointTourCommentDTO[];
    tourCheckPointState?: TourCheckPointState;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: ITourCheckPointDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourId = data["tourId"];
            this.tour = data["tour"] ? TourAgentDTO.fromJS(data["tour"]) : <any>undefined;
            this.checkPointId = data["checkPointId"];
            this.checkPoint = data["checkPoint"] ? CheckPointDTO.fromJS(data["checkPoint"]) : <any>undefined;
            if (data["checkPointTourComments"] && data["checkPointTourComments"].constructor === Array) {
                this.checkPointTourComments = [];
                for (let item of data["checkPointTourComments"])
                    this.checkPointTourComments.push(CheckPointTourCommentDTO.fromJS(item));
            }
            this.tourCheckPointState = data["tourCheckPointState"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TourCheckPointDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourCheckPointDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourId"] = this.tourId;
        data["tour"] = this.tour ? this.tour.toJSON() : <any>undefined;
        data["checkPointId"] = this.checkPointId;
        data["checkPoint"] = this.checkPoint ? this.checkPoint.toJSON() : <any>undefined;
        if (this.checkPointTourComments && this.checkPointTourComments.constructor === Array) {
            data["checkPointTourComments"] = [];
            for (let item of this.checkPointTourComments)
                data["checkPointTourComments"].push(item.toJSON());
        }
        data["tourCheckPointState"] = this.tourCheckPointState;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITourCheckPointDTO {
    id?: number;
    tourId?: number;
    tour?: TourAgentDTO;
    checkPointId?: number;
    checkPoint?: CheckPointDTO;
    checkPointTourComments?: CheckPointTourCommentDTO[];
    tourCheckPointState?: TourCheckPointState;
    startDate?: Date;
    endDate?: Date;
}

export class CheckPointTourCommentDTO implements ICheckPointTourCommentDTO {
    id?: number;
    tourCheckPointId?: number;
    tourCheckPoint?: TourCheckPointDTO;
    commentId?: number;
    comment?: CommentDTO;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: ICheckPointTourCommentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourCheckPointId = data["tourCheckPointId"];
            this.tourCheckPoint = data["tourCheckPoint"] ? TourCheckPointDTO.fromJS(data["tourCheckPoint"]) : <any>undefined;
            this.commentId = data["commentId"];
            this.comment = data["comment"] ? CommentDTO.fromJS(data["comment"]) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckPointTourCommentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPointTourCommentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourCheckPointId"] = this.tourCheckPointId;
        data["tourCheckPoint"] = this.tourCheckPoint ? this.tourCheckPoint.toJSON() : <any>undefined;
        data["commentId"] = this.commentId;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICheckPointTourCommentDTO {
    id?: number;
    tourCheckPointId?: number;
    tourCheckPoint?: TourCheckPointDTO;
    commentId?: number;
    comment?: CommentDTO;
    createdBy?: string;
    createdOn?: Date;
}

export class CheckPointTourCommentDTODataSourceResult implements ICheckPointTourCommentDTODataSourceResult {
    data?: CheckPointTourCommentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ICheckPointTourCommentDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CheckPointTourCommentDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): CheckPointTourCommentDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPointTourCommentDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ICheckPointTourCommentDTODataSourceResult {
    data?: CheckPointTourCommentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class CommentDTODataSourceResult implements ICommentDTODataSourceResult {
    data?: CommentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ICommentDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CommentDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): CommentDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ICommentDTODataSourceResult {
    data?: CommentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class CompanyDTODataSourceResult implements ICompanyDTODataSourceResult {
    data?: CompanyDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ICompanyDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CompanyDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): CompanyDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ICompanyDTODataSourceResult {
    data?: CompanyDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class LocalizationDTO implements ILocalizationDTO {
    id?: number;
    key?: string;
    valueAr?: string;
    valueEn?: string;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: ILocalizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.valueAr = data["valueAr"];
            this.valueEn = data["valueEn"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LocalizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["valueAr"] = this.valueAr;
        data["valueEn"] = this.valueEn;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ILocalizationDTO {
    id?: number;
    key?: string;
    valueAr?: string;
    valueEn?: string;
    createdBy?: string;
    createdOn?: Date;
}

export class LocalizationDTODataSourceResult implements ILocalizationDTODataSourceResult {
    data?: LocalizationDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ILocalizationDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(LocalizationDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): LocalizationDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ILocalizationDTODataSourceResult {
    data?: LocalizationDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export enum NotificationType {
    _1 = 1, 
    _2 = 2, 
}

export class NotificationDTO implements INotificationDTO {
    id?: number;
    text?: string;
    notificationType?: NotificationType;
    toAgentId?: string;
    toAgent?: AgentDTO;
    createdBy?: string;
    createdOn?: Date;

    constructor(data?: INotificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            this.notificationType = data["notificationType"];
            this.toAgentId = data["toAgentId"];
            this.toAgent = data["toAgent"] ? AgentDTO.fromJS(data["toAgent"]) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["notificationType"] = this.notificationType;
        data["toAgentId"] = this.toAgentId;
        data["toAgent"] = this.toAgent ? this.toAgent.toJSON() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface INotificationDTO {
    id?: number;
    text?: string;
    notificationType?: NotificationType;
    toAgentId?: string;
    toAgent?: AgentDTO;
    createdBy?: string;
    createdOn?: Date;
}

export class NotificationDTODataSourceResult implements INotificationDTODataSourceResult {
    data?: NotificationDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: INotificationDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(NotificationDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): NotificationDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface INotificationDTODataSourceResult {
    data?: NotificationDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class PermissionDTODataSourceResult implements IPermissionDTODataSourceResult {
    data?: PermissionDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: IPermissionDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(PermissionDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): PermissionDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface IPermissionDTODataSourceResult {
    data?: PermissionDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class RoleDetailsDTO implements IRoleDetailsDTO {
    id?: number;
    roleNameAr?: string;
    roleNameEn?: string;
    permissions?: number[];

    constructor(data?: IRoleDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleNameAr = data["roleNameAr"];
            this.roleNameEn = data["roleNameEn"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleNameAr"] = this.roleNameAr;
        data["roleNameEn"] = this.roleNameEn;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface IRoleDetailsDTO {
    id?: number;
    roleNameAr?: string;
    roleNameEn?: string;
    permissions?: number[];
}

export class RoleDTODataSourceResult implements IRoleDTODataSourceResult {
    data?: RoleDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: IRoleDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(RoleDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): RoleDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface IRoleDTODataSourceResult {
    data?: RoleDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class TourAgentDTODataSourceResult implements ITourAgentDTODataSourceResult {
    data?: TourAgentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ITourAgentDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TourAgentDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): TourAgentDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new TourAgentDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ITourAgentDTODataSourceResult {
    data?: TourAgentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class LocationQrCodeDTO implements ILocationQrCodeDTO {
    checkPointId?: number;
    qrCode?: string;

    constructor(data?: ILocationQrCodeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkPointId = data["checkPointId"];
            this.qrCode = data["qrCode"];
        }
    }

    static fromJS(data: any): LocationQrCodeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocationQrCodeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkPointId"] = this.checkPointId;
        data["qrCode"] = this.qrCode;
        return data; 
    }
}

export interface ILocationQrCodeDTO {
    checkPointId?: number;
    qrCode?: string;
}

export class TourCheckPointDTODataSourceResult implements ITourCheckPointDTODataSourceResult {
    data?: TourCheckPointDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ITourCheckPointDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TourCheckPointDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): TourCheckPointDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new TourCheckPointDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ITourCheckPointDTODataSourceResult {
    data?: TourCheckPointDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class TourCommentDTODataSourceResult implements ITourCommentDTODataSourceResult {
    data?: TourCommentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ITourCommentDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TourCommentDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): TourCommentDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new TourCommentDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ITourCommentDTODataSourceResult {
    data?: TourCommentDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class HomeTourDTO implements IHomeTourDTO {
    tourId?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    tourType?: string;
    tourTypeId?: number;
    tourDate?: Date;
    estimateDistance?: number;
    locationAr?: string;
    locationEn?: string;
    timeDuration?: string;
    countOfLocations?: number;
    agentId?: string;
    agent?: AgentDTO;

    constructor(data?: IHomeTourDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tourId = data["tourId"];
            this.tourNameAr = data["tourNameAr"];
            this.tourNameEn = data["tourNameEn"];
            this.tourType = data["tourType"];
            this.tourTypeId = data["tourTypeId"];
            this.tourDate = data["tourDate"] ? new Date(data["tourDate"].toString()) : <any>undefined;
            this.estimateDistance = data["estimateDistance"];
            this.locationAr = data["locationAr"];
            this.locationEn = data["locationEn"];
            this.timeDuration = data["timeDuration"];
            this.countOfLocations = data["countOfLocations"];
            this.agentId = data["agentId"];
            this.agent = data["agent"] ? AgentDTO.fromJS(data["agent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HomeTourDTO {
        data = typeof data === 'object' ? data : {};
        let result = new HomeTourDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tourId"] = this.tourId;
        data["tourNameAr"] = this.tourNameAr;
        data["tourNameEn"] = this.tourNameEn;
        data["tourType"] = this.tourType;
        data["tourTypeId"] = this.tourTypeId;
        data["tourDate"] = this.tourDate ? this.tourDate.toISOString() : <any>undefined;
        data["estimateDistance"] = this.estimateDistance;
        data["locationAr"] = this.locationAr;
        data["locationEn"] = this.locationEn;
        data["timeDuration"] = this.timeDuration;
        data["countOfLocations"] = this.countOfLocations;
        data["agentId"] = this.agentId;
        data["agent"] = this.agent ? this.agent.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHomeTourDTO {
    tourId?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    tourType?: string;
    tourTypeId?: number;
    tourDate?: Date;
    estimateDistance?: number;
    locationAr?: string;
    locationEn?: string;
    timeDuration?: string;
    countOfLocations?: number;
    agentId?: string;
    agent?: AgentDTO;
}

export class CommentDetailsDTO implements ICommentDetailsDTO {
    id?: number;
    commentByNameAr?: string;
    commentByNameEn?: string;
    text?: string;
    profileImage?: string;

    constructor(data?: ICommentDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.commentByNameAr = data["commentByNameAr"];
            this.commentByNameEn = data["commentByNameEn"];
            this.text = data["text"];
            this.profileImage = data["profileImage"];
        }
    }

    static fromJS(data: any): CommentDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commentByNameAr"] = this.commentByNameAr;
        data["commentByNameEn"] = this.commentByNameEn;
        data["text"] = this.text;
        data["profileImage"] = this.profileImage;
        return data; 
    }
}

export interface ICommentDetailsDTO {
    id?: number;
    commentByNameAr?: string;
    commentByNameEn?: string;
    text?: string;
    profileImage?: string;
}

export class CheckPointDetailsDTO implements ICheckPointDetailsDTO {
    id?: number;
    checkPointNameAr?: string;
    checkPointNameEn?: string;
    estimatedDistance?: number;
    locationName?: string;
    endDate?: Date;
    qrCode?: string;
    checkPointState?: TourCheckPointState;
    comments?: CommentDTO[];

    constructor(data?: ICheckPointDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.checkPointNameAr = data["checkPointNameAr"];
            this.checkPointNameEn = data["checkPointNameEn"];
            this.estimatedDistance = data["estimatedDistance"];
            this.locationName = data["locationName"];
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.qrCode = data["qrCode"];
            this.checkPointState = data["checkPointState"];
            if (data["comments"] && data["comments"].constructor === Array) {
                this.comments = [];
                for (let item of data["comments"])
                    this.comments.push(CommentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckPointDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPointDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkPointNameAr"] = this.checkPointNameAr;
        data["checkPointNameEn"] = this.checkPointNameEn;
        data["estimatedDistance"] = this.estimatedDistance;
        data["locationName"] = this.locationName;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["qrCode"] = this.qrCode;
        data["checkPointState"] = this.checkPointState;
        if (this.comments && this.comments.constructor === Array) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICheckPointDetailsDTO {
    id?: number;
    checkPointNameAr?: string;
    checkPointNameEn?: string;
    estimatedDistance?: number;
    locationName?: string;
    endDate?: Date;
    qrCode?: string;
    checkPointState?: TourCheckPointState;
    comments?: CommentDTO[];
}

export class TourCheckpointDetailsDTO implements ITourCheckpointDetailsDTO {
    id?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    tourDate?: Date;
    tourState?: TourState;
    adminCommnets?: CommentDetailsDTO[];
    checkPoints?: CheckPointDetailsDTO[];

    constructor(data?: ITourCheckpointDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourNameAr = data["tourNameAr"];
            this.tourNameEn = data["tourNameEn"];
            this.tourDate = data["tourDate"] ? new Date(data["tourDate"].toString()) : <any>undefined;
            this.tourState = data["tourState"];
            if (data["adminCommnets"] && data["adminCommnets"].constructor === Array) {
                this.adminCommnets = [];
                for (let item of data["adminCommnets"])
                    this.adminCommnets.push(CommentDetailsDTO.fromJS(item));
            }
            if (data["checkPoints"] && data["checkPoints"].constructor === Array) {
                this.checkPoints = [];
                for (let item of data["checkPoints"])
                    this.checkPoints.push(CheckPointDetailsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TourCheckpointDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourCheckpointDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourNameAr"] = this.tourNameAr;
        data["tourNameEn"] = this.tourNameEn;
        data["tourDate"] = this.tourDate ? this.tourDate.toISOString() : <any>undefined;
        data["tourState"] = this.tourState;
        if (this.adminCommnets && this.adminCommnets.constructor === Array) {
            data["adminCommnets"] = [];
            for (let item of this.adminCommnets)
                data["adminCommnets"].push(item.toJSON());
        }
        if (this.checkPoints && this.checkPoints.constructor === Array) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITourCheckpointDetailsDTO {
    id?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    tourDate?: Date;
    tourState?: TourState;
    adminCommnets?: CommentDetailsDTO[];
    checkPoints?: CheckPointDetailsDTO[];
}

export class TourTemplateDTO implements ITourTemplateDTO {
    id?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    checkPoints?: TourCheckPointDTO[];
    active?: boolean;

    constructor(data?: ITourTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourNameAr = data["tourNameAr"];
            this.tourNameEn = data["tourNameEn"];
            if (data["checkPoints"] && data["checkPoints"].constructor === Array) {
                this.checkPoints = [];
                for (let item of data["checkPoints"])
                    this.checkPoints.push(TourCheckPointDTO.fromJS(item));
            }
            this.active = data["active"];
        }
    }

    static fromJS(data: any): TourTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourNameAr"] = this.tourNameAr;
        data["tourNameEn"] = this.tourNameEn;
        if (this.checkPoints && this.checkPoints.constructor === Array) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        data["active"] = this.active;
        return data; 
    }
}

export interface ITourTemplateDTO {
    id?: number;
    tourNameAr?: string;
    tourNameEn?: string;
    checkPoints?: TourCheckPointDTO[];
    active?: boolean;
}

export class PointLocationDTO implements IPointLocationDTO {
    id?: number;
    checkPointId?: number;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IPointLocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.checkPointId = data["checkPointId"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PointLocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PointLocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkPointId"] = this.checkPointId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPointLocationDTO {
    id?: number;
    checkPointId?: number;
    startDate?: Date;
    endDate?: Date;
}

export class TourCreateDTO implements ITourCreateDTO {
    id?: number;
    tourType?: TourType;
    tourId?: number;
    tourName?: string;
    tourDate?: Date;
    pointLocations?: PointLocationDTO[];
    agentId?: string;
    captureLocation?: number;
    isTemplate?: boolean;
    adminComment?: string;

    constructor(data?: ITourCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tourType = data["tourType"];
            this.tourId = data["tourId"];
            this.tourName = data["tourName"];
            this.tourDate = data["tourDate"] ? new Date(data["tourDate"].toString()) : <any>undefined;
            if (data["pointLocations"] && data["pointLocations"].constructor === Array) {
                this.pointLocations = [];
                for (let item of data["pointLocations"])
                    this.pointLocations.push(PointLocationDTO.fromJS(item));
            }
            this.agentId = data["agentId"];
            this.captureLocation = data["captureLocation"];
            this.isTemplate = data["isTemplate"];
            this.adminComment = data["adminComment"];
        }
    }

    static fromJS(data: any): TourCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TourCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tourType"] = this.tourType;
        data["tourId"] = this.tourId;
        data["tourName"] = this.tourName;
        data["tourDate"] = this.tourDate ? this.tourDate.toISOString() : <any>undefined;
        if (this.pointLocations && this.pointLocations.constructor === Array) {
            data["pointLocations"] = [];
            for (let item of this.pointLocations)
                data["pointLocations"].push(item.toJSON());
        }
        data["agentId"] = this.agentId;
        data["captureLocation"] = this.captureLocation;
        data["isTemplate"] = this.isTemplate;
        data["adminComment"] = this.adminComment;
        return data; 
    }
}

export interface ITourCreateDTO {
    id?: number;
    tourType?: TourType;
    tourId?: number;
    tourName?: string;
    tourDate?: Date;
    pointLocations?: PointLocationDTO[];
    agentId?: string;
    captureLocation?: number;
    isTemplate?: boolean;
    adminComment?: string;
}

export class TourDTODataSourceResult implements ITourDTODataSourceResult {
    data?: TourDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;

    constructor(data?: ITourDTODataSourceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TourDTO.fromJS(item));
            }
            this.count = data["count"];
            this.countUnReaded = data["countUnReaded"];
            this.qrCodeType = data["qrCodeType"];
        }
    }

    static fromJS(data: any): TourDTODataSourceResult {
        data = typeof data === 'object' ? data : {};
        let result = new TourDTODataSourceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["countUnReaded"] = this.countUnReaded;
        data["qrCodeType"] = this.qrCodeType;
        return data; 
    }
}

export interface ITourDTODataSourceResult {
    data?: TourDTO[];
    count?: number;
    countUnReaded?: number;
    qrCodeType?: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new SwaggerException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}